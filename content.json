{"pages":[],"posts":[{"title":"数据结构基础总结","text":"&emsp;经过漫长的等待后，果然头条的面试挂掉了。突然发现自己打了这么久的ACM，很多基础数据结构的概念掌握的还不是非常的牢固。这些数据结构可能并不难，特别是跳表和线段数组这样的数据结构，但是由于平日的疏忽导致这些概念有少许的以往。那么今天就要对这些掌握不是特别牢固的数据结构一一进行总结。 一 跳表 &emsp;跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。&emsp;跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。&emsp;跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。 &emsp;假设每M个元素构建索引，元素链表中总共有N个元素，那么构建的索引数如下： 第一级有：n/M 个第二级有：n/(M^2)个元素…….第k级有：n/(M^k)个元素 &emsp;假设第k级为最后一级则可知，n/(M^k) = M, k = logn - 1, 再加上原始链表总共logn级平均每级搜索元素个数 = M + 1 ; 时间复杂度 = O(log(n)) 空间复杂度 = n/M + n/(M^2) + … + n/(M^k) = O(n) 引用自简书liuzhengqiu 二 线段树&emsp;了解线段树前我们需要了解二叉树，线段树是二叉树的一种，他是一颗二叉搜索树。线段树上的每一个节点代表一个区间，同样也可以理解为一个线段，搜索则是在这些线段上进行搜索从而获得答案。 &emsp;为了进一步的学习线段树，我们首先需要了解线段树的功能是什么，有过OI基础/ACM基础的同学们通常会认为线段树主要用于处理区间查询问题。但是在实际应用中可能线段树的功能比区间查询更加丰富，当然这里我们还是需要从区间查询问题开始说起。 更新点，查询区间更新区间，查询点更新区间，查询区间 &emsp;通常来说，利用线段树处理的问题分为上面三种，通常而言线段树的时间复杂度是O(log2(N))，线段树的空间复杂度&lt;4n。下面通过一张图来显示线段树每个节点储存的信息，例子采用的是区间长度为10的数组。 &emsp;可以发现，每个叶子结点的值就是数组的值，每个非叶子结点的度都为二，且左右两个孩子分别存储父亲一半的区间。每个父亲的存储的值也就是两个孩子存储的值的最大值。 &emsp;通过对上图的观察我们现在可以清晰的了解线段树点更新，区间更新，点查询，区间查询的方法。具体的代码需要在网上寻找，每个人都有自己独特的写法，如果是竞赛选手，强烈建议形成自己的一套模板。 参考CSDN代码 三 线段数组&emsp;要了解线段数组，我们需要先了解树状数组，顾名思义，树状数组即利用数组构建树形结构。这种结构相比树形结构可以极大程度的降低内存的消耗，故在比赛中我们常常利用树状数组来解决线段树的问题，而不是动态开点。 &emsp;与普通的线段树相同，利用线段数组可以轻松的完成区间的修改、查询。他的复杂度和线段树相同均为O(logN)，但是相比线段树，树状数组拥有更小的常数，所以最终运行的速度更快。 四 红黑树红黑树具有下面五种特征： 性质1：每个节点要么是黑色，要么是红色。性质2：根节点是黑色。性质3：每个叶子节点（NIL）是黑色。性质4：每个红色结点的两个子结点一定都是黑色。性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 &emsp;红黑树是一种特殊的二叉平衡树，它通过左旋，右旋和变色来保持自平衡。他是一个非常负责的数据结构，在本篇中仅简单介绍其功能。更加丰富的内容日后会开专题介绍。","link":"/2019/07/12/data-structure/"},{"title":"网络编程之python-socket编程","text":"&emsp;对于python的socket编程，在之前仅有非常基础的了解。通常来说我们会利用以下的代码完成我们的socket编程。 1234567while True: # 接受一个新连接: sock, addr = s.accept() # 阻塞 # 直接进行一些操作 # or 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() &emsp;直接进行一些操作将会造成非常严重的阻塞问题，直观的来看，似乎采用多线程/进程的方式可以解决这个问题，但是其实并不然如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。1 &emsp;很多人可能会采用线程池、进程池的方法减少创建和销毁进程线程的次数，降低系统因为销毁或者创建进程/线程消耗的系统资源。但是在大规模的系统中仍然可能会遇到瓶颈。所以这里我们会采用非阻塞式接口来解决这个问题。 一 非阻塞IO&emsp;在python-socket编程中，设置setblocking的值为False(默认为True)，那么现在accept()将不再阻塞。常规的非阻塞式IO的代码如下 2 1234567891011121314151617181920212223while True: try: conn, addr = sock.accept() # 被动接受TCP客户的连接，等待连接的到来，收不到时会报异常 print('connect by ', addr) conn_list.append(conn) conn.setblocking(False) # 设置非阻塞 except BlockingIOError as e: pass tmp_list = [conn for conn in conn_list] for conn in tmp_list: try: data = conn.recv(1024) # 接收数据1024字节 if data: print('收到的数据是{}'.format(data.decode())) conn.send(data) else: print('close conn',conn) conn.close() conn_list.remove(conn) print('还有客户端=&gt;',len(conn_list)) except IOError: pass &emsp;但是从上述的代码我们可以观察到，虽然非阻塞式IO解决了阻塞的问题，一个进程可以同时干其他的任务，但是非阻塞式IO是非常不被推荐的，由于不断地while(True)可能会导致CPU资源占满，无故消耗了许多不需要消耗的系统资源。 二 多路复用IOselect模型&emsp;把socket交给操作系统去监控，相当于找个代理人(select), 去收快递。快递到了,就通知用户，用户自己去取。&emsp;阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用 &emsp;使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 12345678910111213141516171819s_list = [s.fileno(),] #fileno()获取套接字的唯一描述符,每个套接字都是唯一不同的s_dict = {}while 1: list_readable,a,b = select(s_list,[],[]) #分别对应: 输入,输出,错误输出 for i in list_readable: if i == s.fileno(): conn,userinfo = s.accept() s_list.append(conn.fileno()) s_dict[conn.fileno()] = conn else: cs = s_dict[i] recv_data = cs.recv(1024) if len(recv_data) &lt;= 0: s_dict[i].close() s_dict.pop(i) s_list.remove(i) else: cs.send(recv_data) &emsp;但是select模型的复杂度较高，每次会不断的轮询所负责的所有socket描述符，当某个socket有数据到达了，就通知用户进程。所以select模型主要存在以下的问题 3 最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select 模型的最大并发数就被相应限制了。当然我们也可以采用修改FD_SETSIZE从而增加最大并发数。 效率问题， select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把 FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了。 内核 / 用户空间 内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法，在FD非常多的时候，非常的耗费时间。 &emsp;上述三点可以总结为：1.连接数受限 2.查找配对速度慢 3.数据由内核拷贝到用户态消耗时间 epoll模型&emsp;epoll模型是对select模型的改进，其效率非常高，但仅可用于Unix/Linux操作系统。由于其非常重要，这里完整摘取python源码。 4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#创建socket对象serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#设置IP地址复用serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)#ip地址和端口号server_address = (\"127.0.0.1\", 8888)#绑定IP地址serversocket.bind(server_address)#监听，并设置最大连接数serversocket.listen(10)print \"服务器启动成功，监听IP：\" , server_address#服务端设置非阻塞serversocket.setblocking(False) #超时时间timeout = 10#创建epoll事件对象，后续要监控的事件添加到其中epoll = select.epoll()#注册服务器监听fd到等待读事件集合epoll.register(serversocket.fileno(), select.EPOLLIN)#保存连接客户端消息的字典，格式为{}message_queues = {}#文件句柄到所对应对象的字典，格式为{句柄：对象}fd_to_socket = {serversocket.fileno():serversocket,}while True: print \"等待活动连接......\" #轮询注册的事件集合，返回值为[(文件句柄，对应的事件)，(...),....] events = epoll.poll(timeout) if not events: print \"epoll超时无活动连接，重新轮询......\" continue print \"有\" , len(events), \"个新事件，开始处理......\" for fd, event in events: socket = fd_to_socket[fd] #如果活动socket为当前服务器socket，表示有新连接 if socket == serversocket: connection, address = serversocket.accept() print \"新连接：\" , address #新连接socket设置为非阻塞 connection.setblocking(False) #注册新连接fd到待读事件集合 epoll.register(connection.fileno(), select.EPOLLIN) #把新连接的文件句柄以及对象保存到字典 fd_to_socket[connection.fileno()] = connection #以新连接的对象为键值，值存储在队列中，保存每个连接的信息 message_queues[connection] = Queue.Queue() #关闭事件 elif event &amp; select.EPOLLHUP: print 'client close' #在epoll中注销客户端的文件句柄 epoll.unregister(fd) #关闭客户端的文件句柄 fd_to_socket[fd].close() #在字典中删除与已关闭客户端相关的信息 del fd_to_socket[fd] #可读事件 elif event &amp; select.EPOLLIN: #接收数据 data = socket.recv(1024) if data: print \"收到数据：\" , data , \"客户端：\" , socket.getpeername() #将数据放入对应客户端的字典 message_queues[socket].put(data) #修改读取到消息的连接到等待写事件集合(即对应客户端收到消息后，再将其fd修改并加入写事件集合) epoll.modify(fd, select.EPOLLOUT) else: print 'closing', address, 'after reading no data' epoll.unregister(fd) connections[fd].close() del connections[fd] #可写事件 elif event &amp; select.EPOLLOUT: try: #从字典中获取对应客户端的信息 msg = message_queues[socket].get_nowait() except Queue.Empty: print socket.getpeername() , \" queue empty\" #修改文件句柄为读事件 epoll.modify(fd, select.EPOLLIN) else : print \"发送数据：\" , data , \"客户端：\" , socket.getpeername() #发送数据 socket.send(msg)#在epoll中注销服务端文件句柄epoll.unregister(serversocket.fileno())#关闭epollepoll.close()#关闭服务器socketserversocket.close() &emsp;但客户端的代码基本与其他模型无疑，这里对客户端代码做基本记录。 1234567891011121314151617#创建客户端socket对象clientsocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#服务端IP地址和端口号元组server_address = ('127.0.0.1',8888)#客户端连接指定的IP地址和端口号clientsocket.connect(server_address)while True: #输入数据 data = raw_input('please input:') #客户端发送数据 clientsocket.sendall(data) #客户端接收数据 server_data = clientsocket.recv(1024) print '客户端收到的数据：'server_data #关闭客户端socket clientsocket.close() &emsp;通过上述的这些样例，大致了解了python如何利用内核模型进行编程，但是由于缺少编程经验，暂时尚未掌握这些操作在实习开发时如何运用。希望未来能对这个领域进行更深一步的理解，届时将再次更新总结对内核模型的理解。","link":"/2019/07/14/python-socket/"},{"title":"初窥http（1）——浏览器中输入url后到底发生了什么","text":"&emsp;在学校里学习计算机网络的过程中，由于《计算机网络》课本内容较为底层基础，许多人在学习完这本书后都会产生一定的困惑。譬如，现在互联网有哪些地方运用到了哪些协议，这些协议最新的标准是什么样子的等等。为了解决心中的困惑，我决定先对日常中最常用的http-web中所采用的协议进行更深一步的了解，为此我在图灵社区中购置了《图解http》一书。接下来将按照自己的思路从书中获取一些问题的答案。 &emsp;本文是购置该书籍后发表的第一篇记录，在这篇记录里，我将揭秘在浏览器中输入url后发生的一系列事情。 浏览器中输入url后主要会发生下面的几件事 一 负责域名解析的DNS服务&emsp;计算机可以被赋予ip地址，同样的也可以被赋予主机名和域名。例如本博客的ip地址是185.199.109.153（github io服务器地址），域名地址为 blog.100innovate.com。我们通常使用域名去访问不同的计算机和网站，域名相比一串数字来说更有利于人们的记忆，但是计算机更擅长于处理ip地址这样的数字。 &emsp;为了解决计算机和人的矛盾，DNS服务在这个时候就产生了，通过DNS服务我们可以通过域名查询ip，或者利用ip查询域名。（通常而言，人们仅利用域名查询ip，很少利用ip查询域名） &emsp;在浏览器中输入url并键入回车后的第一步，浏览器将会向DNS服务器发送查询请求，从而获取目标服务器的ip地址。 二 互联网的基础TCP/IP协议&emsp;计算机想要相互通信，就需要一个标准的数据交换协议，这个协议就是TCP/IP协议。通常而言浏览器访问web网站时采用的是TCP协议，TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，为了保证通信的可靠新，首先需要进行三次握手，三次握手的主要流程为：1.客户端向服务器端发送SYN标记的数据包2.服务器端向客户端发送SYN/ACK标记的数据包3.客户端向服务器端发送ACK标记的数据包 &emsp;采用三次握手而不是两次握手有许多原因，原因之一是防止延期到达的数据包传输到服务器，服务器会因此创建一个无效的连接。 三 通过HTTP协议传输数据&emsp;HTTP协议的职责是生成针对目标Web服务器的HTTP请求报文，主要有如下的请求方法： GET:获取资源POST:传输实体主体HEAD:获取报文首部PUT:传输文件DELETE:删除文件OPTIONS:询问支持的方法TRACE:追踪路径…… &emsp;利用上述的数种请求报文向服务器发送请求报文，从而获取用户需要访问的内容。请求报文主要包含请求方法、URI、协议版本三个信息。 &emsp;在向服务器发送完请求报文后，服务器会返回请求的结果。当然每一次返回的结果并非绝对正确，为了表达服务器对用户请求的各种状态，http协议设置了规定了状态码，通过返回状态码告知浏览器服务器处理的情况，状态码通常的定义如下： 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 &emsp;通常来说，只要遵守上述状态码的规则，服务提供商可以自行创建状态码。 &emsp;通过上述请求协议和服务器返回报文，最终浏览器可以获得用户需要的数据和信息。 四 浏览器解析并渲染页面&emsp;在浏览器成功获取html信息后，将会按照顺序从头至尾解析html文件，在解析到外部的css、js等其他外部资源文件的时候，根据服务器、浏览器的版本不同将会直接向服务器请求资源文件，或者重新建立TCP连接，然后请求资源文件。值得一提的是，在解析html文件时，浏览器将会构建DOM树，为了加速这一过程，浏览器还会使用预解析等功能。 &emsp;在完成html的解析后，浏览器还需要根据浏览器的窗口位置等信息，逐像素的将网页绘制出来。最终我们可以获得想要看到的网页。 五 小结&emsp;通过对《图解http》进行全篇大致浏览，解决了一大问题。但是需要学习的仍然还有人多，譬如现代浏览器一些处理机制问题以及近年来我们常常使用的https与http有什么不同，这些疑惑就留到日后逐一破解。","link":"/2019/07/10/http-01/"},{"title":"初窥http（2）——加密版本的http协议https协议","text":"&emsp;紧随初窥http（1），这次探索的是现代网站常用的加密协议https。https的主要功能是确保web安全。它主要弥补了http下面的几个不足： 使用明文通信，内容可能会被窃听无法验证通信方的身份，可能存在伪装的情况无法验证报文的完整性，报文可能遭到修改。 &emsp;这些问题通常会出现在所有非加密的信息传输协议中。为了解决上述的三个问题https应运而生。 一 什么是https&emsp;利用SSL或者TLS的组合使用，加密HTTP的通信内容。通过SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信。与SSL组合使用的HTTP被称为HTTPS或者HTTP over SSL。 二 对称加密非对称加密&emsp;对称加密和非对称加密是我们常常使用的加密算法，对称加密时通信双方使用同一个密钥，此时如何保障该密钥的传输成为一个重大难题，通常来说在一些必要的情况下设备厂商会在设备内预置一些密钥对，这样在一定程度上保证通信安全。而非对称加密，一对密钥由公钥和私钥组成，私钥解密公钥加密数据，公钥解密私钥加密数据。私钥只能由一个设备保管，但是公钥可以公开给所有人，根据算法相关的知识我们可以知道，这种通信方式更为安全，但是传输速度收到加密解密速度的影响。 &emsp;所以在https中，同时使用到了对称加密和非对称加密，非对称加密主要用于服务器的验证，对称加密主要用于大量数据的传输，利用对称加密和非对称加密的特点，共同解决http数据传输时的安全问题。 三 https过程详解&emsp;关于HTTPS安全通信机制和HTTPS的通信步骤，不同人有不同的理解办法，这里引用《图解http》里面的内容来详细介绍这一过程。 摘选书中的内容主要分为下面12个步骤。 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。 之后服务器发送Certificate 报文。报文中包含公开密钥证书。 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。 SSL第一次握手结束之后，客户端以Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。 接着客户端继续发送Change Cipher Spec报文。该报文会 提示服务器，在此报文之后的通信会采用Pre-master secret 密钥加密。 客户端发送Finished报文。该报文包含连接至今全部报文 的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 服务器同样发送Change Cipher Spec报文。 服务器同样发送Finished报文。 服务器和客户端的Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。 应用层协议通信，即发送HTTP响应。 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP 的通信。","link":"/2019/07/13/http-02/"},{"title":"后端面试基础——进程与线程","text":"&emsp;刚刚经历了大学以来的第一次面试，不得不说头条作为宇宙厂面试有非常高的难度，平日进行的简单开发和底层的深入理解不可而与，为了更加透彻的理解进程与线程，这里特别对进程和线程相关的知识进行总结。并且利用准确的术语来表述进程和线程的特点以及关系。 一 进程的基本概念&emsp;进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。作为一个程序执行的一个实体，是系统分配资源的基本单位。 &emsp;进程通信主要有五种通信方式，分别是管道、命名管道、信号量、消息队列、共享内存。 二 线程的基本概念&emsp;线程是进程的一个执行单元，是进程的一个特定执行路径。当一个线程修改了进程的资源，同一个进程下的其他线程将会立即看到这种变化。 &emsp;相较于进程，由于线程共享进程中的全局变量，所以通常而言不需要特别的线程通信方式，在C/C++中我们常利用volatile关键词使编译器不对代码段进行优化，无需将该值放入寄存器中，使该值可以被外部改变。或者利用windows消息队列进行线程通信。此外还可以利用std中std::promise、std::packaged_task来进行线程通信。 三 进程和线程的主要区别及优势区别：1.代码段、内存:进程间相互独立，同一进程的各线程间共享。线程仅在同一个进程内可见。 2.通信：进程间通信IPC（管道、命名管道、信号量、共享内存、消息队列），线程间通信相对进程间通信更为简单，直接使用全局变量即可。但是使用时需要考虑锁机制和同步机制。 3.调度和切换：线程上下文切换比进程上下文切换快得多。 4.在多线程OS中，进程不是一个可执行的实体。 选择：1.需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程的代价是很大的。 2.线程的切换速度快，所以在需要大量计算，切换频繁时使用线程，还有耗时的操作时用使用线程可提高应用程序的响应。 3.因为对CPU系统的效率使用上线程更占优势，所以可能要发展到多机分布的用进程，多核分布用线程。 4.并行操作时用线程，如C/S架构的服务器端并发线程响应用户的请求。 5.需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。 资源引用：什么是进程？什么是线程？进程和线程之间的区别是什么？","link":"/2019/07/11/process-thread/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"跳表","slug":"跳表","link":"/tags/跳表/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"线段数组","slug":"线段数组","link":"/tags/线段数组/"},{"name":"红黑树","slug":"红黑树","link":"/tags/红黑树/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"I/O","slug":"I-O","link":"/tags/I-O/"},{"name":"epoll","slug":"epoll","link":"/tags/epoll/"},{"name":"select","slug":"select","link":"/tags/select/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/tags/TCP-IP/"},{"name":"图解http","slug":"图解http","link":"/tags/图解http/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"非对称加密","slug":"非对称加密","link":"/tags/非对称加密/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"进程","slug":"进程","link":"/tags/进程/"},{"name":"线程","slug":"线程","link":"/tags/线程/"},{"name":"今日头条","slug":"今日头条","link":"/tags/今日头条/"}],"categories":[{"name":"面试基础","slug":"面试基础","link":"/categories/面试基础/"},{"name":"初窥http","slug":"初窥http","link":"/categories/初窥http/"}]}